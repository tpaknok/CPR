[{"path":"https://tpaknok.github.io/CPR/articles/Empirical.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Empirical Analyses with CPR","text":"R Markdown document describing empirical analyses conducted Tsang et al. (2024). , need install load multiple packages data. Let’s structure data properly first. KSR_EF data multiple ecosystem function.","code":"library(phytools) library(tidyverse) library(CPR) data(KSR) data(KSR_MLtree) data(KSR_EF) excluded <- anti_join(KSR, KSR_EF, by = c(\"PLOT\" = \"Plot\")) KSR <- semi_join(KSR, KSR_EF, by = c(\"PLOT\" = \"Plot\")) KSR_EF <- KSR_EF %>% arrange(factor(Plot,levels=KSR$PLOT))  KSR_misc <- KSR$PLOT KSR <- KSR[,-1] KSR[is.na(KSR)] <- 0 KSR <- KSR[rowSums(KSR) > 0,]  KSR_MLtree <- keep.tip(KSR_MLtree,colnames(KSR)) VCV_sp <- vcv(KSR_MLtree) #species level phyologenetic covariance matrix using default (Brownian) model VCV_sp <- VCV_sp[order(rownames(VCV_sp)),order(colnames(VCV_sp))] VCV_comm <- get_comm_pair_r(KSR,VCV_sp) head(KSR_EF) #>   Plot Real.rich Legume       Hed       PD     MNND      MPD         H #> 1   X2         1      N 0.0000000   0.0000   0.0000   0.0000 0.0000000 #> 2   X3         4     LP 1.3772918 456.7786 136.7786 258.9262 1.1761865 #> 3   X4         2      N 0.6931472 320.0000 320.0000 320.0000 0.2249718 #> 4   X7         1      N 0.0000000   0.0000   0.0000   0.0000 0.0000000 #> 5   X8         3     LP 1.0934269 418.9892 238.6522 279.3261 0.7560967 #> 6   X9         1      N 0.0000000   0.0000   0.0000   0.0000 0.0000000 #>        Simp biomass2012 litter2012 biomass2013 biomass2014 ave.biomass #> 1 0.0000000       47.89      79.05       35.39       15.64    32.97333 #> 2 0.6712373      122.24      74.23       74.33       50.66    82.41000 #> 3 0.1115254       77.93      34.50       59.62       51.23    62.92667 #> 4 0.0000000       44.37      36.32       44.69       14.09    34.38333 #> 5 0.5120332      166.82      21.46      148.84      125.51   147.05667 #> 6 0.0000000       44.37      37.26       32.12       24.92    33.80333 #>   Light.tau  LAI C.change.deep C.change.surf N.change.deep N.change.surf #> 1     0.312 1.67        -0.331        -0.031         0.007        -0.010 #> 2     0.031 5.53         1.762         0.111        -0.046        -0.009 #> 3     0.100 3.04        -0.518         0.421        -0.012         0.024 #> 4     0.083 3.42        -0.156        -0.009        -0.087        -0.028 #> 5     0.006 7.14            NA            NA        -0.045         0.031 #> 6     0.499 1.01        -1.895        -0.128         0.066         0.017 #>   mean.N.change poll_total flwr_total Mass.loss.1month Mass.loss.2month #> 1       -0.0015         20 43113.5000            2.891            3.362 #> 2       -0.0275         53  2126.1429            3.147            3.718 #> 3        0.0060        150   324.4286            2.972            3.521 #> 4       -0.0575          0     0.0000            2.714            3.328 #> 5       -0.0070          0     0.0000            3.283            3.608 #> 6        0.0415          0     0.0000            3.020            3.627 #>         GRASS SOAL       MOFI ASTU       DECA Damage_effect bugs bug.rich #> 1          NA   NA         NA   NA         NA     0.0000000    9        7 #> 2 -0.34584386   NA         NA   NA 0.04572438    -0.3001195    7        6 #> 3 -0.04241343   NA -0.3771144   NA         NA    -0.4195279    4        2 #> 4          NA   NA         NA   NA         NA     0.0000000    5        3 #> 5 -2.74600928   NA         NA   NA         NA    -2.7460093    4        4 #> 6          NA   NA         NA   NA         NA     0.0000000   11        7"},{"path":[]},{"path":"https://tpaknok.github.io/CPR/articles/Empirical.html","id":"empirical-analyses","dir":"Articles","previous_headings":"","what":"Empirical analyses","title":"Empirical Analyses with CPR","text":"repeated analyses Cadotte et al. (2017), involving ten ecosystem functions. one ecosystem function interest (don’t mind code clunky), can just use INLA write similar functions ten times. example… case, used lapply . coding complicated. Now let’s visualize findings","code":"library(nlme) KSR_EF$log_flwr_total <- log10(KSR_EF$flwr_total+1) #log-transforming floral abundance to facilitate covnergence in INLA  KSR_EF$comm <- 1:nrow(KSR_EF) #need to create an unique identifier for each comm in INLA m <- lm(log_flwr_total~Real.rich,data=KSR_EF)  sdres <- sd(residuals(m)) param <- c(3*sdres,0.01) prior1 <- list(prec=list(prior=\"pc.prec\"),param=param) #you don't need to follow everything here. You can specify your own prior too.  f <- log_flwr_total~Real.rich+f(comm,model=\"generic0\",Cmatrix=P.lambda,hyper=list(prec = prior1)) #start with the formula. Note that P.lambda is just a placeholder  #You can also provide multiple prior  ML.opt2<-optim(runif(1,0.2,0.8),                likelihood.lambda.INLA,                inla_formula= f,                family=\"gaussian\",                data=KSR_EF,                phyV=VCV_sp,                comm=KSR,                prior = list(prior1 = prior1),                control.compute = list(waic=T),                method=\"L-BFGS-B\",                lower=0.0,                upper=1.0,                control=list(factr=1e9)) #SLOW  lambda_INLA<-ML.opt2$par wAIC <- ML.opt2$value VCV_sp_INLA <- VCV_sp*lambda_INLA diag(VCV_sp_INLA) <- diag(VCV_sp) C.lambda.INLA<- get_comm_pair_r(KSR,VCV_sp_INLA)   prec.mat.INLA <- solve(C.lambda.INLA) #note that INLA requires a precision matrix, not a VCV  optim_m <- inla(log_flwr_total~Real.rich+f(comm,                                            model=\"generic0\",                                            Cmatrix=prec.mat.INLA,                                            hyper=list(prec = prior1)),                 data=KSR_EF)  lm_m <- inla(log_flwr_total~Real.rich,                 data=KSR_EF)  summary(optim_m) summary(lm_m) library(nlme) ef_name <- c(\"litter2012\",\"ave.biomass\",\"LAI\",\"bug.rich\",\"bugs\",\"poll_total\",\"log_flwr_total\",\"Mass.loss.2month\",\"Damage_effect\",\"mean.N.change\") #ecosystem functions analyzed ef <- KSR_EF[,ef_name] C <- get_comm_pair_r(KSR,VCV_sp)  f <- y~x+f(comm,model=\"generic0\",Cmatrix=P.lambda,hyper=list(prec = prior1)) family <- ifelse(ef_name == \"bug.rich\" | ef_name == \"bugs\" | ef_name == \"poll_total\",                  \"poisson\",                  \"gaussian\")  ef_empiricial <- function(ef_data,x,VCV_sp,names,ef_properties,comm,family) {   print(ef_properties)   y <- ef_data   df <- data.frame(y=y,x=x)   df$comm <- 1:nrow(df)      m <- glm(y~x,            family = family,            data = df)      summary(m)   m_sig <- summary(m)$coefficients[2,4]    sdres <- sd(residuals(m))   param <- c(3*sdres,0.01)   prior1 <- list(prec=list(prior=\"pc.prec\"),param=param)      ML.opt2<-optim(runif(1,0.2,0.8),                  likelihood.lambda.INLA,                  inla_formula = f,                  family = family,                  data = df,                  phyV = VCV_sp,                  comm = KSR,                  prior = list(prior1 = prior1),                  control.compute = list(waic=T),                  method = \"L-BFGS-B\",                  lower = 0.0,                  upper = 1.0,                  control = list(factr=1e9))      lambda_INLA<-ML.opt2$par   wAIC <- ML.opt2$value   V_INLA <- VCV_sp*lambda_INLA   diag(V_INLA) <- diag(VCV_sp)   C.lambda.INLA<- get_comm_pair_r(comm,V_INLA)       newobs <- data.frame(y=NA,x=unique(x),comm=NA)   INLA_df <- rbind(df,newobs)      m2_INLA_LM <- inla(y~x,                      data=INLA_df,                      family=family,                      control.compute = list(dic=T,waic=T))   m2_INLA_LM <- inla.rerun(m2_INLA_LM)   wAIC_LM <- m2_INLA_LM$waic$waic   m2_INLA_LM_r2<- cor(m2_INLA_LM$summary.fitted.values[1:(nrow(df)),\"mean\"],df$y)^2      prec.mat.INLA <- solve(C.lambda.INLA)   m2_INLA_optim <- inla(y~x+f(comm,                               model=\"generic0\",                               Cmatrix=prec.mat.INLA,                               prior = \"pc.prec\",                               hyper= c(3*sd(residuals(m)),0.01)),                         family = family,                         data = INLA_df,control.predictor=list(compute=TRUE),                         control.compute = list(dic=T,waic=T),                         safe=T,                         control.inla = list(tolerance = 1e-10))   m2_INLA_optim <- inla.rerun(m2_INLA_optim) # https://groups.google.com/g/r-inla-discussion-group/c/qkoV9ZtA1Wo   m2_INLA_optim <- inla.rerun(m2_INLA_optim) # https://groups.google.com/g/r-inla-discussion-group/c/qkoV9ZtA1Wo      summary(m2_INLA_optim)   m2_INLA_optim_predict <- m2_INLA_optim$summary.fitted.values[-1:-(nrow(df)),]   m2_INLA_optim_predict <- data.frame(newobs$x,m2_INLA_optim_predict[,c(\"mean\",\"0.025quant\",\"0.975quant\")])   m2_INLA_optim_predict$sig <- ifelse(sign(m2_INLA_optim$summary.fixed)[2,3] == sign(m2_INLA_optim$summary.fixed)[2,5],-1,1)   m2_INLA_optim_r2 <- cor(m2_INLA_optim$summary.fitted.values[1:nrow(df),\"mean\"],df$y)^2      library(ggeffects)   m_predict <- data.frame(ggeffect(m,terms=\"x\"),sig=m_sig)   m_predict <- m_predict[,c(1,2,4,5,7)]   colnames(m2_INLA_optim_predict) <- colnames(m_predict)      ###summarize the data into a dataframe   predict_df <- rbind(cbind(m_predict,                             model=\"OLS\",                             ef=ef_properties,                             lambda=NA,                             hyper_Gaussian = NA,                              hyper_Comm = NA,                             wAIC = wAIC_LM,                             r2=m2_INLA_LM_r2,                             mean=m2_INLA_LM$summary.fixed[2,1],                             lower_quant=m2_INLA_LM$summary.fixed[2,3],                             upper_quant=m2_INLA_LM$summary.fixed[2,5]),                       cbind(m2_INLA_optim_predict,                             model=\"Optimized INLA\",                             ef=ef_properties,                             lambda=lambda_INLA,                             hyper_Gaussian=m2_INLA_optim$summary.hyperpar[1,1],                             hyper_Comm =m2_INLA_optim$summary.hyperpar[2,1],                             wAIC=wAIC,                             r2=m2_INLA_optim_r2,                             mean=m2_INLA_optim$summary.fixed[2,1],                             lower_quant=m2_INLA_optim$summary.fixed[2,3],                             upper_quant=m2_INLA_optim$summary.fixed[2,5]))      return(predict_df) }  df <- data.frame(x=KSR_EF$Real.rich) #seems that ggeffect can only extract variables from global environments predict_df <- lapply(1:ncol(ef),function(x) ef_empiricial(ef_data=ef[,x],                                                           x=KSR_EF$Real.rich,                                                           VCV_sp=VCV_sp,                                                           ef_properties=ef_name[x],                                                           comm=KSR,                                                           family=family[x]))  predict_df <- do.call(rbind,predict_df) predict_df$x <- predict_df$x predict_df$sig_binary <- ifelse(predict_df$sig < 0.05,\"Significant\",\"Insignificant\") library(ggplot2) library(tidyverse) plot_data <- KSR_EF %>%    select(any_of(ef_name)|\"Real.rich\") %>%   #select(contains(\"2015.2017\") | contains(\"NumSp\")) %>%   pivot_longer(!Real.rich,names_to=\"ef\")  plot_data$ef <- fct_relevel(plot_data$ef,                             \"litter2012\",                             \"ave.biomass\",                             \"LAI\",                             \"poll_total\",                             \"log_flwr_total\",                             \"Mass.loss.2month\",                             \"Damage_effect\",                             \"mean.N.change\",                             \"bugs\",                             \"bug.rich\")  predict_df$ef <- fct_relevel(predict_df$ef,                              \"litter2012\",                              \"ave.biomass\",                              \"LAI\",                              \"poll_total\",                              \"log_flwr_total\",                              \"Mass.loss.2month\",                              \"Damage_effect\",                              \"mean.N.change\",                              \"bugs\",                              \"bug.rich\")  predict_df$ratio <- predict_df$hyper_Gaussian/predict_df$hyper_Comm predict_df$ratio <- (1/predict_df$hyper_Gaussian)/(1/predict_df$hyper_Comm)  p <- ggplot(data=predict_df)+   geom_jitter(data=plot_data,aes(y=value,x=Real.rich),width=0)+   geom_line(aes(y=predicted,x=x,colour=model,linetype=sig_binary))+   geom_ribbon(aes(y=predicted,x=x,fill=model,ymin=conf.low,ymax=conf.high),alpha=0.3,colour=\"transparent\")+   facet_wrap(~ef,scales=\"free\",nrow=5,ncol=2)+   theme_classic()+   labs(x=\"Species richness\",y=\"Ecosystem Function\",colour=\"Model\",fill=\"Model\",linetype=\"Significance\")+   scale_linetype_manual(values=c(2,1))+   scale_colour_manual(values=c(\"#000000\",\"#E69F00\"))+   scale_fill_manual(values=c(\"#000000\",\"#E69F00\"))+   theme(legend.position=\"bottom\")  plot(p)"},{"path":"https://tpaknok.github.io/CPR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Toby Pak Nok Tsang. Maintainer.","code":""},{"path":"https://tpaknok.github.io/CPR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Tsang TPN (2024). CPR: Community Phylogenetic Regression. R package version 0.1.0, https://tpaknok.github.io/CPR/, https://github.com/tpaknok/CPR.","code":"@Manual{,   title = {CPR: Community Phylogenetic Regression},   author = {Toby Pak Nok Tsang},   year = {2024},   note = {R package version 0.1.0, https://tpaknok.github.io/CPR/},   url = {https://github.com/tpaknok/CPR}, }"},{"path":"https://tpaknok.github.io/CPR/index.html","id":"cpr-under-development","dir":"","previous_headings":"","what":"Community Phylogenetic Regression","title":"Community Phylogenetic Regression","text":"package CPR address phylogenetic non-independence species community analyses.","code":""},{"path":"https://tpaknok.github.io/CPR/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Community Phylogenetic Regression","text":"can install development version CPR GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"tpaknok/CPR\",build_vignettes=TRUE,force=TRUE)"},{"path":"https://tpaknok.github.io/CPR/index.html","id":"background","dir":"","previous_headings":"","what":"Background","title":"Community Phylogenetic Regression","text":"species known non-independent due shared evolutionary history, rarely considered community-level analyses. Additionally, communities statistically indepedent species overlap (often case). analysis accounts non-independence species within communities using Bayesian GLMM. Composition matrices presence/absence, number individuals, percent cover, biomass etc can used. Matrices based scoring systems uneven intervals can also used (e.g., DAFOR), can lead interpretation issues. Users can calculate variance-covariance matrix based phylogeny model (e.g. Brownian motions). resulting variance-covariance matrix positive definite, nearPD Matrix package applied find nearest positive definite matrix. Without positive definite matrix PGLS fail run. Please make sure species compositional matrix phylogenetic matrix identical species name (e.g., space denoted ” “, ”_” “.”). “get_comm_pair_r” return variance-covariance matrix community level, can used gls (nlme). likelihood_lambda.R extracted Revell et al. (2010, Methods Ecology & Evolution). Similar PGLS, function optimizes phylogenetic covariance matrix minimizing log-likelihood. default lambda value restricted 0-1. functions used simulations / empirical analyses producing figures Note using Bayesian GLMM rather Frequentist GLMM improve speed.","code":""},{"path":"https://tpaknok.github.io/CPR/index.html","id":"known-problems","dir":"","previous_headings":"","what":"Known problems","title":"Community Phylogenetic Regression","text":"Might need use inla.rerun enhance model stability possible communities indeed independent sample even species overlap. cases optimization lambda produce unstable results. fix 1) re-run optimization several times see results largely stable 2) compare wAIC models optimized lambda independence assumption. model optimized lambda doesn’t perform better, users can use model assuming communities independent. Note even phylogenetic matrix, INLA give different results across runs. re-running model give different slightly different results (phylogeny important). phylogeny unimportant, INLA give unstable results, wAIC lambda values driven random fluctutation across runs.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"Getting pairwise phylogenetic correlation communities","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"","code":"get_comm_pair_r(comm,V,force.PD = TRUE)"},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"comm species-site matrix V phylogenetic covariance matrix species levels force.PD find closest positive definite matrix community levels.   Default TRUE. Note matrix positive definite subsequent analyses can fail.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"resulting phylogenetic correlation matrix based additive law covariance.   Imagine two communities species (X,Y) species (X,Z). Covariance community levels   Cov(X+Y,X+Z) = Var(X)+Cov(X,Z)+Cov(X,Y)+Cov(Y,Z). components can obtained     species level phylogenetic matrix.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"phylogenetic correlation matrix community levels.","code":""},{"path":[]},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"Toby P.N. Tsang","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"","code":"library(phytools) #> Loading required package: ape #> Loading required package: maps library(tidyverse) #> ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── #> ✔ dplyr     1.1.4     ✔ readr     2.1.4 #> ✔ forcats   1.0.0     ✔ stringr   1.5.1 #> ✔ ggplot2   3.4.4     ✔ tibble    3.2.1 #> ✔ lubridate 1.9.2     ✔ tidyr     1.3.0 #> ✔ purrr     1.0.2      #> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── #> ✖ dplyr::filter() masks stats::filter() #> ✖ dplyr::lag()    masks stats::lag() #> ✖ purrr::map()    masks maps::map() #> ✖ dplyr::where()  masks ape::where() #> ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors library(CPR) data(KSR) data(KSR_MLtree) data(KSR_EF)  KSF_EF <- KSR_EF %>% arrange(factor(Plot,levels=KSR$PLOT)) excluded <- anti_join(KSR, KSR_EF, by = c(\"PLOT\" = \"Plot\")) KSR <- semi_join(KSR, KSR_EF, by = c(\"PLOT\" = \"Plot\"))  KSR_misc <- KSR$PLOT KSR <- KSR[,-1] KSR[is.na(KSR)] <- 0 KSR <- KSR[rowSums(KSR) > 0,]  KSR_MLtree <- keep.tip(KSR_MLtree,colnames(KSR)) VCV_sp <- vcv(KSR_MLtree) #species level phyologenetic covariance matrix using default (Brownian) model VCV_comm <- get_comm_pair_r(KSR,VCV_sp) #> Loading required package: Matrix #>  #> Attaching package: 'Matrix' #> The following objects are masked from 'package:tidyr': #>  #>     expand, pack, unpack #> Loading required package: matrixcalc"}]
