[{"path":"https://tpaknok.github.io/CPR/articles/Empirical_multiple.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Empirical Analyses with CPR - Multiple Functions","text":"Assuming multiple ecosystem functions analyse, can repeat code single ecosystem function analyses multiple times. bit annoying though, especially lot data! , provide example use loop . First, load data .","code":"library(phytools) library(tidyverse) library(CPR) library(INLA) data(\"KSR\") data(\"KSR_MLtree\") data(\"KSR_EF\") VCV_sp <- vcv(KSR_MLtree) #species level phyologenetic covariance matrix using default (Brownian) model VCV_sp <- VCV_sp[order(rownames(VCV_sp)),order(colnames(VCV_sp))] VCV_comm <- get_comm_pair_r(KSR,VCV_sp)"},{"path":"https://tpaknok.github.io/CPR/articles/Empirical_multiple.html","id":"data-explorations","dir":"Articles","previous_headings":"","what":"Data Explorations","title":"Empirical Analyses with CPR - Multiple Functions","text":"use lapply . ten ecosystem functions, different statistical properties. examples, arthropod abundance must integer, damage reduction effects continuous. visualize distributions different ecosystem functions, can see spike zero! Thus, use different distributions different ecosystem functions. example, use negative binomial integer data, zeroinflated negative binomial integer data many zeros. continuous data, can use normal distribution, tweedie distribution many zeroes. need create lists store different formulas, name distribution, priors different models. Let’s . inla.set.contro.family.default indicates use default priors hyperparameters. However, tweedie distribution, specified non-informative prior.","code":"plot(hist(KSR_EF$LAI)) plot(hist(KSR_EF$flwr_total))"},{"path":"https://tpaknok.github.io/CPR/articles/Empirical_multiple.html","id":"model-setups","dir":"Articles","previous_headings":"","what":"Model Setups","title":"Empirical Analyses with CPR - Multiple Functions","text":"can simply use lapply loop everything. take time run!!!","code":"y <- c(\"poll_total\",        \"bugs\",        \"bug.rich\",        \"litter2012\",        \"ave.biomass\",        \"flwr_total\",        \"Mass.loss.2month\",        \"LAI\",        \"mean.N.change\",        \"Damage_effect\") #response  x <- \"Real.rich\" # predictors re <- 'f(comm,model=\"generic0\",Cmatrix=Phylo)' #random effect  family <- list(\"zeroinflatednbinomial1\",             \"nbinomial\",             \"nbinomial\",             \"gaussian\",             \"gaussian\",             \"tweedie\",             \"gaussian\",             \"gaussian\",             \"gaussian\",             \"gaussian\") #family for each response  formulas <- lapply(paste0(y,\"~\",x,\"+\",re),function(x) as.formula(x))  control.family<- list(inla.set.control.family.default(\"zeroinflatednbinomial1\"),                       inla.set.control.family.default(\"nbinomial\"),                       inla.set.control.family.default(\"nbinomial\"),                       inla.set.control.family.default(\"gaussian\"),                       inla.set.control.family.default(\"gaussian\"),                        list(hyper = list(                          theta1 = list(initial = 0),                          theta2 = list(initial = 0,                                        prior = \"normal\",                                        param = c(0,2)))),                       inla.set.control.family.default(\"gaussian\"),                       inla.set.control.family.default(\"gaussian\"),                       inla.set.control.family.default(\"gaussian\"),                       inla.set.control.family.default(\"gaussian\")) #hyperparameter priors  KSR_EF_list <- lapply(1:10,function(x) KSR_EF) #create ten sets of KSR_EF data comm_list <- lapply(1:10, function(x) KSR) #ten sets of comm data  KSR_EF_list[[10]] <- subset(KSR_EF_list[[10]], Real.rich > 1) #for damage effect, we exclude monoculture communities comm_list[[10]] <- KSR[rowSums(KSR) >1,] #for damage effect, we exclude monoculture communities"},{"path":"https://tpaknok.github.io/CPR/articles/Empirical_multiple.html","id":"empirical-analyses---multiple-functions","dir":"Articles","previous_headings":"","what":"Empirical Analyses - Multiple Functions","title":"Empirical Analyses with CPR - Multiple Functions","text":"","code":"BEF_KSR <- lapply(1:length(family), function(x) CPR(formulas[[x]],                                                     priors=NULL,                                                     df = KSR_EF_list[[x]],                                                     VCV_sp = VCV_sp,                                                     comm=comm_list[[x]],                                                     family=family[[x]],                                                     control.family=control.family[[x]],                                                     inla.rerun=3,                                                     optim.lambda = T)) #> [1] \"poll_total\" #> [1] \"bugs\" #> [1] \"bug.rich\" #> [1] \"litter2012\" #> [1] \"ave.biomass\" #> [1] \"flwr_total\" #> [1] \"Mass.loss.2month\" #> [1] \"LAI\" #> [1] \"mean.N.change\" #> [1] \"Damage_effect\""},{"path":"https://tpaknok.github.io/CPR/articles/Empirical_multiple.html","id":"visualizations","dir":"Articles","previous_headings":"","what":"Visualizations","title":"Empirical Analyses with CPR - Multiple Functions","text":"visualize expected effect species richness different ecosystem functions, need extract predictions model. make figure, also need restructure KSR_EF wide format long format. Also, flower abundance ranged 0-60000, presented findings log-scale (although analyses log transform , tweedie use log link). Now just ggplot2 code, figure Tsang et al. (2024) produced.","code":"all_predictions <- do.call(rbind,sapply(1:10, function(x) BEF_KSR[[x]]$prediction)) plot_data <- KSR_EF %>%   select(any_of(y)|\"Real.rich\") %>%   pivot_longer(!Real.rich,names_to=\"response\")  plot_data$value[plot_data$response == \"flwr_total\"] <- log(plot_data$value[plot_data$response == \"flwr_total\"]+1) all_predictions[all_predictions$response == \"flwr_total\",c(\"0.5quant\",\"0.025quant\",\"0.975quant\")] <- log(all_predictions[all_predictions$response == \"flwr_total\",c(\"0.5quant\",\"0.025quant\",\"0.975quant\")]+1) library(ggplot2) p <- ggplot(data=all_predictions)+   geom_jitter(data=plot_data,aes(y=value,x=Real.rich),width=0)+   geom_line(aes(y=`0.5quant`,x=Real.rich,colour=model,linetype=Sig))+   geom_ribbon(aes(y=`0.5quant`,x=Real.rich,fill=model,ymin=`0.025quant`,ymax=`0.975quant`),alpha=0.3,colour=\"transparent\")+   facet_wrap(~response,scales=\"free\",nrow=5,ncol=2)+   theme_classic()+   labs(x=\"Species richness\",y=\"Ecosystem function\",colour=\"Model\",fill=\"Model\",linetype=\"Significance\")+   scale_linetype_manual(values=c(2,1))+   scale_colour_manual(values=c(\"#000000\",\"#E69F00\"))+   scale_fill_manual(values=c(\"#000000\",\"#E69F00\"))+   theme(legend.position=\"bottom\")  plot(p)"},{"path":"https://tpaknok.github.io/CPR/articles/Empirical_single.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Empirical Analyses with CPR - Single Function","text":"R Markdown document describing use CPR conduct BEF regression, community-level analyses. need install load multiple packages data. Let’s get variane covariance matrix species community level. KSR_EF data multiple ecosystem function.","code":"library(phytools) library(tidyverse) library(CPR) data(\"KSR\") data(\"KSR_MLtree\") data(\"KSR_EF\") VCV_sp <- vcv(KSR_MLtree) #species level phyologenetic covariance matrix using default (Brownian) model VCV_sp <- VCV_sp[order(rownames(VCV_sp)),order(colnames(VCV_sp))] VCV_comm <- get_comm_pair_r(KSR,VCV_sp) VCV_comm[1:5,1:5] #>           [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 1.0000000 0.7031681 0.5639611 0.5601336 0.7539047 #> [2,] 0.7031681 1.0000000 0.5458038 0.5420995 0.7048548 #> [3,] 0.5639611 0.5458038 1.0000000 0.9932127 0.5749535 #> [4,] 0.5601336 0.5420995 0.9932127 1.0000000 0.5710514 #> [5,] 0.7539047 0.7048548 0.5749535 0.5710514 1.0000000 head(KSR_EF) #>   Plot Real.rich litter2012 ave.biomass  LAI mean.N.change poll_total flwr_total Mass.loss.2month #> 1   X2         1      79.05    32.97333 1.67       -0.0015         20 43113.5000            3.362 #> 2   X3         4      74.23    82.41000 5.53       -0.0275         53  2126.1429            3.718 #> 3   X4         2      34.50    62.92667 3.04        0.0060        150   324.4286            3.521 #> 4   X7         1      36.32    34.38333 3.42       -0.0575          0     0.0000            3.328 #> 5   X8         3      21.46   147.05667 7.14       -0.0070          0     0.0000            3.608 #> 6   X9         1      37.26    33.80333 1.01        0.0415          0     0.0000            3.627 #>   Damage_effect bugs bug.rich #> 1     0.0000000    9        7 #> 2     0.3001195    7        6 #> 3     0.4195279    4        2 #> 4     0.0000000    5        3 #> 5     2.7460093    4        4 #> 6     0.0000000   11        7"},{"path":[]},{"path":"https://tpaknok.github.io/CPR/articles/Empirical_single.html","id":"empirical-analyses---single-function","dir":"Articles","previous_headings":"","what":"Empirical Analyses - Single Function","title":"Empirical Analyses with CPR - Single Function","text":"repeated analyses Cadotte et al. (2017), involving ten ecosystem functions. one ecosystem function interest (don’t mind code clunky), can just use INLA write similar functions ten times. example, let’s analyze flower abundance. INLA powerful package, can bit complicated use. Bayesian analysis, specify priors. INLA different default priors check website interested. simplicty’s sake, use default prior random fixed effects, uninformative case. However, dispersion parameter tweedie, actually used gaussian distribution N~(0,2). Note prior log-scale internal calculation INLA. ’s default setting loggamma (100,100) seems narrow range, thus becoming informative, least dataset. Generally, think carefully prior constructions. Default priors always uninformative, can huge influence data! syntax INLA different packages like lme4 glmmTMB. random effect, need use f() provide necessary argument. manually computed covariance matrix, need first convert precision matrix, throw Cmatrix argument. Also, need set model “generic0”. use CPR, need supply species-level covariance matrix VCV_sp, add “Phylo” Cmatrix argument. Phylo just placeholder internal calculation CPR automatically convert covariance matrix precision matrix (even optimize covariance matrix wish ). also need add ID plot, CPR function internally create column named “comm” automatically. INLA sometimes might fail run, rerun automatically. don’t need worry . choose optimize phylogenetic signal, might take run! patient!","code":"inla_m <- CPR(formula = bugs~Real.rich+f(comm,model=\"generic0\",Cmatrix=Phylo),               priors=NULL,               df = KSR_EF,               VCV_sp = VCV_sp,               comm=KSR,               family=\"nbinomial\",               optim.lambda = T) #> [1] \"bugs\"  summary(inla_m$best_model) #>  #> Call: #>    c(\"inla.core(formula = formula, family = family, contrasts = contrasts, \", \" data = data,  #>    quantiles = quantiles, E = E, offset = offset, \", \" scale = scale, weights = weights,  #>    Ntrials = Ntrials, strata = strata, \", \" lp.scale = lp.scale, link.covariates =  #>    link.covariates, verbose = verbose, \", \" lincomb = lincomb, selection = selection,  #>    control.compute = control.compute, \", \" control.predictor = control.predictor,  #>    control.family = control.family, \", \" control.inla = control.inla, control.fixed =  #>    control.fixed, \", \" control.mode = control.mode, control.expert = control.expert, \", \"  #>    control.hazard = control.hazard, control.lincomb = control.lincomb, \", \" control.update =  #>    control.update, control.lp.scale = control.lp.scale, \", \" control.pardiso = control.pardiso,  #>    only.hyperparam = only.hyperparam, \", \" inla.call = inla.call, inla.arg = inla.arg,  #>    num.threads = num.threads, \", \" keep = keep, working.directory = working.directory, silent =  #>    silent, \", \" inla.mode = inla.mode, safe = FALSE, debug = debug, .parent.frame =  #>    .parent.frame)\" )  #> Time used: #>     Pre = 0.227, Running = 0.248, Post = 0.163, Total = 0.638  #> Fixed effects: #>              mean    sd 0.025quant 0.5quant 0.975quant  mode kld #> (Intercept) 2.129 0.344      1.419    2.140      2.775 2.140   0 #> Real.rich   0.076 0.097     -0.116    0.076      0.267 0.076   0 #>  #> Random effects: #>   Name     Model #>     comm Generic0 model #>  #> Model hyperparameters: #>                                                        mean    sd 0.025quant 0.5quant 0.975quant mode #> size for the nbinomial observations (1/overdispersion) 2.54 0.514      1.675     2.48       3.69 2.38 #> Precision for comm                                     2.48 1.356      0.808     2.18       5.97 1.68 #>  #> Watanabe-Akaike information criterion (WAIC) ...: 617.33 #> Effective number of parameters .................: 11.80 #>  #> Marginal log-Likelihood:  -866.36  #>  is computed  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')"},{"path":"https://tpaknok.github.io/CPR/articles/Empirical_single.html","id":"residual-checking","dir":"Articles","previous_headings":"","what":"Residual Checking","title":"Empirical Analyses with CPR - Single Function","text":"Let’s model diagnostics make sure model makes sense. First, use function INLA_simulate obtain simulated response model. put DHARMa conduct different diagnostics. can see data don’t deviate lot expected line QQ plot, good thing. Also, obvious pattern residual graph….model ok.","code":"library(DHARMa) #> This is DHARMa 0.4.6. For overview type '?DHARMa'. For recent changes, type news(package = 'DHARMa') sres <- INLA_simulate(inla_m$best_model) DHARMa_res <- createDHARMa(sres,                            KSR_EF$bugs,                            fittedPredictedResponse=inla_m$predictedfittedresponse,                            integerResponse = T) plot(DHARMa_res,quantreg=F)"},{"path":"https://tpaknok.github.io/CPR/articles/Empirical_single.html","id":"a-bad-example","dir":"Articles","previous_headings":"","what":"A Bad Example","title":"Empirical Analyses with CPR - Single Function","text":"Now let’s try run analyses poisson distribution see happens. hyperparameter poisson distribution use default settings INLA. Clearly worse fit negative binomial! knew poisson distributions often fail describe ecological data properly. functions DHARMa, check package build robust models!","code":"inla_m2 <- CPR(formula = bugs~Real.rich+f(comm,model=\"generic0\",Cmatrix=Phylo),               priors=NULL,               df = KSR_EF,               VCV_sp = VCV_sp,               comm=KSR,               family=\"poisson\") #> [1] \"bugs\"  summary(inla_m2$best_model) #>  #> Call: #>    c(\"inla.core(formula = formula, family = family, contrasts = contrasts, \", \" data = data,  #>    quantiles = quantiles, E = E, offset = offset, \", \" scale = scale, weights = weights,  #>    Ntrials = Ntrials, strata = strata, \", \" lp.scale = lp.scale, link.covariates =  #>    link.covariates, verbose = verbose, \", \" lincomb = lincomb, selection = selection,  #>    control.compute = control.compute, \", \" control.predictor = control.predictor,  #>    control.family = control.family, \", \" control.inla = control.inla, control.fixed =  #>    control.fixed, \", \" control.mode = control.mode, control.expert = control.expert, \", \"  #>    control.hazard = control.hazard, control.lincomb = control.lincomb, \", \" control.update =  #>    control.update, control.lp.scale = control.lp.scale, \", \" control.pardiso = control.pardiso,  #>    only.hyperparam = only.hyperparam, \", \" inla.call = inla.call, inla.arg = inla.arg,  #>    num.threads = num.threads, \", \" keep = keep, working.directory = working.directory, silent =  #>    silent, \", \" inla.mode = inla.mode, safe = FALSE, debug = debug, .parent.frame =  #>    .parent.frame)\" )  #> Time used: #>     Pre = 0.219, Running = 0.199, Post = 0.0739, Total = 0.492  #> Fixed effects: #>              mean    sd 0.025quant 0.5quant 0.975quant  mode kld #> (Intercept) 2.013 0.250      1.513    2.016      2.496 2.016   0 #> Real.rich   0.024 0.061     -0.098    0.024      0.143 0.024   0 #>  #> Random effects: #>   Name     Model #>     comm Generic0 model #>  #> Model hyperparameters: #>                    mean    sd 0.025quant 0.5quant 0.975quant mode #> Precision for comm 1.55 0.592      0.638     1.47       2.93 1.31 #>  #> Watanabe-Akaike information criterion (WAIC) ...: 872.66 #> Effective number of parameters .................: 69.38 #>  #> Marginal log-Likelihood:  -972.14  #>  is computed  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')  sres2 <- INLA_simulate(inla_m2$best_model) DHARMa_res2 <- createDHARMa(sres2,                            KSR_EF$bugs,                            inla_m2$best_model$predictedfittedresponse,                            integerResponse=T) plot(DHARMa_res2,quantreg=F)"},{"path":"https://tpaknok.github.io/CPR/articles/Empirical_single.html","id":"making-figures","dir":"Articles","previous_headings":"","what":"Making figures","title":"Empirical Analyses with CPR - Single Function","text":"Let’s say want visualize predicted relationships arthropod abundance species richness. Note predict functions doesn’t work INLA, many packages don’t support INLA . use CPR, result automatically provide predicted relationships can pass ggplot make pretty figures. variable, CPR create list. Thus example can extract predicted relationship inla_m$prediction$Real.rich want visualize expected effect species richness. course can just visualize effect /without phylogeny, depending one fits better. Anyway, based models, found evidence arthropod abundance varied across different treatments.","code":"library(ggplot2)  p <- ggplot()+   geom_point(data=KSR_EF,aes(x=Real.rich,y=bugs))+   geom_line(data=inla_m$prediction$Real.rich,aes(x=Real.rich,                                                  y=`0.5quant`,                                                  colour=model,                                                  ),linetype=2)+   geom_ribbon(data=inla_m$prediction$Real.rich,aes(x=Real.rich,                                                    y=`0.5quant`,                                                    ymin=`0.025quant`,                                                    ymax=`0.975quant`,                                                    fill=model,                                                    ),alpha=0.3)+   scale_colour_manual(values=c(\"#000000\",\"#E69F00\"))+   scale_fill_manual(values=c(\"#000000\",\"#E69F00\"))+   labs(x=\"Species richness\",y = \"Arthropod abundance\",fill=\"Model\",colour=\"Model\")+   theme_classic()+   theme(legend.position=\"bottom\")  plot(p)"},{"path":"https://tpaknok.github.io/CPR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Toby Pak Nok Tsang. Maintainer.","code":""},{"path":"https://tpaknok.github.io/CPR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Tsang TPN (2024). CPR: Community Phylogenetic Regression. R package version 0.1.0, https://tpaknok.github.io/CPR/, https://github.com/tpaknok/CPR.","code":"@Manual{,   title = {CPR: Community Phylogenetic Regression},   author = {Toby Pak Nok Tsang},   year = {2024},   note = {R package version 0.1.0, https://tpaknok.github.io/CPR/},   url = {https://github.com/tpaknok/CPR}, }"},{"path":"https://tpaknok.github.io/CPR/index.html","id":"cpr-under-development","dir":"","previous_headings":"","what":"Community Phylogenetic Regression","title":"Community Phylogenetic Regression","text":"package CPR address phylogenetic non-independence species community analyses.","code":""},{"path":"https://tpaknok.github.io/CPR/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Community Phylogenetic Regression","text":"can install development version CPR GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"tpaknok/CPR\")"},{"path":"https://tpaknok.github.io/CPR/index.html","id":"background","dir":"","previous_headings":"","what":"Background","title":"Community Phylogenetic Regression","text":"species known non-independent due shared evolutionary history, rarely considered community-level analyses. Additionally, communities statistically indepedent species overlap (often case). analysis accounts non-independence species within communities using Bayesian GLMM. Composition matrices presence/absence, number individuals, percent cover, biomass etc can used. Matrices based scoring systems uneven intervals can also used (e.g., DAFOR), can lead interpretation issues. Users can calculate variance-covariance matrix based phylogeny model (e.g. Brownian motions). resulting variance-covariance matrix positive definite, nearPD Matrix package applied find nearest positive definite matrix. Without positive definite matrix PGLS fail run. Please make sure species compositional matrix phylogenetic matrix identical species name (e.g., space denoted ” “, ”_” “.”). “get_comm_pair_r” return variance-covariance matrix community level, can used gls (nlme). likelihood_lambda.R extracted Revell et al. (2010, Methods Ecology & Evolution). Similar PGLS, function optimizes phylogenetic covariance matrix minimizing log-likelihood. default lambda value restricted 0-1. functions used simulations / empirical analyses producing figures Note using Bayesian GLMM rather Frequentist GLMM improve speed.","code":""},{"path":"https://tpaknok.github.io/CPR/index.html","id":"known-problems","dir":"","previous_headings":"","what":"Known problems","title":"Community Phylogenetic Regression","text":"Might need use inla.rerun enhance model stability possible communities indeed independent sample even species overlap. cases optimization lambda produce unstable results. fix 1) re-run optimization several times see results largely stable 2) compare wAIC models optimized lambda independence assumption. model optimized lambda doesn’t perform better, users can use model assuming communities independent. Note even phylogenetic matrix, INLA give different results across runs. re-running model give different slightly different results (phylogeny important). phylogeny unimportant, INLA give unstable results, wAIC lambda values driven random fluctutation across runs.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/BEF_simulate.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulating a BEF relationship — BEF_simulate","title":"Simulating a BEF relationship — BEF_simulate","text":"Simulating BEF relationship /without phylogenetic signals. Broadly, can also used simulate relationship phyloogenetic signals.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/BEF_simulate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulating a BEF relationship — BEF_simulate","text":"","code":"BEF_simulate(comm, V, ef_mean, sd, b1 = 0, signals_X = \"sr\", signals_intercept = TRUE, signals_slope = FALSE, lambda_true = 1, sim = 500, seed=1000)"},{"path":"https://tpaknok.github.io/CPR/reference/BEF_simulate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulating a BEF relationship — BEF_simulate","text":"comm species-site matrix. V phylogenetic covariance matrix species levels. ef_mean mean value simulated per-capita effect Y species. default zero. Used signals_X = \"phy_cor\" (see Details) sd standard deviation simulated per-capita effect Y species. default one. Used signals_X = \"phy_cor\" (see Details) b1 value b1, effect X Y. signals_X Type X simulated used. signals_X = \"sr\", species richness used. signals_X = \"phy_cor\", continuous variable phylogenetic signals generated. signals_X = \"no_phy_cor\", continuous variable without phylogenetic signals (\\(N(0,1)\\)) generated. default \"sr\". signals_intercept Phylogenetic signals intercept community. default TRUE. signals_slope Phylogenetic signals slope community. default FALSE. lambda_true Lambda used simulating data. default 1. Ignored signals_intecept signals_slope FALSE. sim Number simulations. default 500. seed seed used simulate data. default 1000.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/BEF_simulate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulating a BEF relationship — BEF_simulate","text":"simulated relationship \\(Y = (b_{0}+Z_{1,comm})+(b_{1}+Z_{0,comm})X\\), \\(b_{0}\\) population-level intercept, \\(b_{1}\\) poluation-level effect \\(X\\), \\(Z_{0,comm}\\) random intercept community, \\(Z_{1,comm}\\) random slope community. signals_intercept signals_slope FALSE, random effects zero. signals_X = \"phy_cor\", X \\(chol({C_{comm})U}\\), \\(U\\) data vector randomly sampled Normal distirbution \\(N(ef\\_ mean,sd)\\), \\(chol({C_{comm})}\\) upper triangular Cholesky decomposition phylogenetic covariance matrix community levels. also way random intercepts slopes generated","code":""},{"path":"https://tpaknok.github.io/CPR/reference/BEF_simulate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulating a BEF relationship — BEF_simulate","text":"list data frames length equals number simulation. data frames contained two columns X Y.","code":""},{"path":[]},{"path":"https://tpaknok.github.io/CPR/reference/BEF_simulate.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulating a BEF relationship — BEF_simulate","text":"Toby P.N. Tsang","code":""},{"path":"https://tpaknok.github.io/CPR/reference/BEF_simulate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulating a BEF relationship — BEF_simulate","text":"","code":"library(phytools) library(tidyverse) library(CPR) data(KSR) data(KSR_MLtree) data(KSR_EF)  VCV_sp <- vcv(KSR_MLtree)  sim_data_lambda_1 <- BEF_simulate(comm = KSR,                                   V = VCV_sp,                                   ef_mean = 0,                                   sd = 1,                                   b1 = 0,                                   signals_X = \"sr\",                                   signals_intercept = TRUE,                                   signals_slope = FALSE,                                   lambda_true = 1,                                   sim = 500)"},{"path":"https://tpaknok.github.io/CPR/reference/BEF_simulate_eval.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate simulation results — BEF_simulate_eval","title":"Evaluate simulation results — BEF_simulate_eval","text":"Evaluating GLS (CPR_GLS) INLA (CPR) results analyzing simulated data BEF_simulate. function evaluate type-/ type-II errors, slope estimates, AIC/wAIC, optimized lambda. Results simulation also provided.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/BEF_simulate_eval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate simulation results — BEF_simulate_eval","text":"","code":"BEF_simulate_eval(models, type = \"INLA\")"},{"path":"https://tpaknok.github.io/CPR/reference/BEF_simulate_eval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate simulation results — BEF_simulate_eval","text":"models list outputs CPR_GLS CPR type \"INLA\" \"GLS\". Defaulted \"INLA\"","code":""},{"path":"https://tpaknok.github.io/CPR/reference/BEF_simulate_eval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate simulation results — BEF_simulate_eval","text":"type = \"GLS\", AIC calculated. type = \"INLA\", wAIC calculated. function always evaluate proportion simulate runs producing statistically significant relationship (.e., p < 0.05). Thus whether represents type-error / power (1-type-II error) depend true b1 specified BEF_simulate.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/BEF_simulate_eval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate simulation results — BEF_simulate_eval","text":"summary_stat return proportion significant results, min max mean slope estimates across runs. result detailed results simulation run slope estimates X. AIC AIC (GLS) wAIC (INLA) model. function evaluates model optimized lambda, model without considering phylogeny, model user-supplied phylogenetic covariance matrix. optim_lambda Sumamry statistics optimized lambda. type INLA/GLS","code":""},{"path":[]},{"path":"https://tpaknok.github.io/CPR/reference/BEF_simulate_eval.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Evaluate simulation results — BEF_simulate_eval","text":"Toby P.N. Tsang","code":""},{"path":[]},{"path":[]},{"path":"https://tpaknok.github.io/CPR/reference/BEF_simulate_eval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate simulation results — BEF_simulate_eval","text":"","code":"library(phytools) library(tidyverse) library(CPR) data(KSR) data(KSR_MLtree) data(KSR_EF)  VCV_sp <- vcv(KSR_MLtree)  ## simulation setup sim <- 20  #20 runs in total optim_sim <- 10 #optimizing lambda in ten runs only to minimize computational time optim_seq <- sample(c(rep(TRUE, optim_sim), rep(FALSE, sim-optim_sim)), sim ,replace = F)  sim_data_lambda_1 <- BEF_simulate(comm = KSR,                                   V = VCV_sp,                                   ef_mean = 0,                                   sd = 1,                                   b1 = 0,                                   signals_X = \"sr\",                                   signals_intercept = TRUE,                                   signals_slope = FALSE,                                   lambda_true = 1,                                   sim = sim)  INLA_formula <-  y~x+f(comm,model=\"generic0\",Cmatrix=Phylo) GLS_formula <- y~x ##  GLS_lambda_1 <- lapply(1:sim, function(x) CPR_GLS(formula = GLS_formula,                                                   df = sim_data_lambda_1$sim_dat[[x]],                                                   VCV_sp = VCV_sp,                                                   optim.lambda = optim_seq[[x]],                                                   comm = KSR))  INLA_lambda_1 <- lapply(1:sim, function(x) CPR(formula = INLA_formula,                                              priors=NULL,                                              df = sim_data_lambda_1$sim_dat[[x]],                                              VCV_sp = VCV_sp,                                              comm=KSR,                                              family= \"gaussian\",                                              inla.rerun=3,                                              optim.lambda = optim_seq[[x]]))  GLS_eval_lambda_1 <- BEF_simulate_eval(GLS_lambda_1,type=\"GLS\") INLA_eval_lambda_1 <- BEF_simulate_eval(INLA_lambda_1,type=\"INLA\")"},{"path":"https://tpaknok.github.io/CPR/reference/CPR_GLS.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized least squares regressino for community data. — CPR_GLS","title":"Generalized least squares regressino for community data. — CPR_GLS","text":"function conducts GLS community-level data. recommended pglmm can better control type-error, power, slope estimates. However, analyses (e.g., piecewiseSEMs), INLA supported yet, compromise use GLS.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/CPR_GLS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized least squares regressino for community data. — CPR_GLS","text":"","code":"CPR_GLS(formula,         df,         VCV_sp,         comm,         optim.lambda = TRUE,         original.VCV = TRUE,         ...)"},{"path":"https://tpaknok.github.io/CPR/reference/CPR_GLS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized least squares regressino for community data. — CPR_GLS","text":"formula gls formula. df data frame. VCV_sp covariance matrix species levels. comm species-site matrix. optim.lambda TRUE/FALSE. TRUE optimial lambda model also returned. original.VCV TRUE/FALSE. TRUE model using supplied VCV_sp also returned. ... arguments passing optim.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/CPR_GLS.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generalized least squares regressino for community data. — CPR_GLS","text":"function calls gls nlme conduct gls, automatically calculate covariance matrix communities using get_comm_pair_r.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/CPR_GLS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized least squares regressino for community data. — CPR_GLS","text":"without_phylo_model model without considering phylogeny (.e., equivalent OLS regression).   optimized_model model optimized \\(\\lambda\\).   original_VCV_model model based phylogenetic covariance matrix provided users (.e., without optimization).  AIC AIC model. optim_lambda optimized \\(\\lambda\\) (.e., \\(\\lambda\\) leading lowest AIC).","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://tpaknok.github.io/CPR/reference/CPR_GLS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized least squares regressino for community data. — CPR_GLS","text":"","code":"library(phytools) library(tidyverse) library(CPR) data(KSR) data(KSR_MLtree) data(KSR_EF)  VCV_sp <- vcv(KSR_MLtree)   GLS_lambda_1 <- CPR_GLS(formula = LAI~Real.rich,                         df = KSR_EF,                         VCV_sp = VCV_sp,                         optim.lambda = TRUE,                         comm = KSR)  GLS_lambda_1$without_phylo_model #models without considering phylogeny GLS_lambda_1$optimized_model #models without considering phylogeny GLS_lambda_1$original_VCV_model #models without considering phylogeny GLS_lambda_1$AIC #AIC of different models GLS_lambda_1$optim_lambda #optimized lambda if available"},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"Getting pairwise phylogenetic correlation communities","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"","code":"get_comm_pair_r(comm,V,force.PD = TRUE)"},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"comm species-site matrix V phylogenetic covariance matrix species levels force.PD find closest positive definite matrix community levels.   Default TRUE. Note matrix positive definite subsequent analyses can fail.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"resulting phylogenetic correlation matrix based additive law covariance. Imagine two communities species (X,Y) species (X,Z). Covariance community levels   Cov(X+Y,X+Z) = Var(X)+Cov(X,Z)+Cov(X,Y)+Cov(Y,Z). components can obtained     species level phylogenetic matrix.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"phylogenetic correlation matrix community levels.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"https://github.com/tpaknok/CPR","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"Toby P.N. Tsang","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"","code":"library(phytools) library(tidyverse) library(CPR) data(KSR) data(KSR_MLtree) data(KSR_EF)  KSR_MLtree <- keep.tip(KSR_MLtree,colnames(KSR)) VCV_sp <- vcv(KSR_MLtree) #species level phyologenetic covariance matrix using default (Brownian) model VCV_comm <- get_comm_pair_r(KSR,VCV_sp)"},{"path":"https://tpaknok.github.io/CPR/reference/likelihood.lambda.INLA.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimizing phylogenetic signals (\\(\\lambda\\)) at community levels for INLA models — likelihood.lambda.INLA","title":"Optimizing phylogenetic signals (\\(\\lambda\\)) at community levels for INLA models — likelihood.lambda.INLA","text":"internal function called CPR. used optim, function compares wAIC models different \\(\\lambda\\) identify best one using L-BFGS-B.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/likelihood.lambda.INLA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimizing phylogenetic signals (\\(\\lambda\\)) at community levels for INLA models — likelihood.lambda.INLA","text":"","code":"likelihood.lambda.INLA(inla_formula,                        data,                        family = \"gaussian\",                        phyV = NULL,                        comm = NULL,                        lambda,                        priors = NULL, ...)"},{"path":"https://tpaknok.github.io/CPR/reference/likelihood.lambda.INLA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimizing phylogenetic signals (\\(\\lambda\\)) at community levels for INLA models — likelihood.lambda.INLA","text":"inla_formula INLA formula data data frame family error distribution (e.g., \"gaussian\",\"poisson\"). See INLA package distribution available. phyV phylogenetic covariance matrix species levels. comm species-site matrix. lambda initial lambda ranging 0.2 0.8/ priors priors used INLA model ... additional arguments passing optim","code":""},{"path":"https://tpaknok.github.io/CPR/reference/likelihood.lambda.INLA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Optimizing phylogenetic signals (\\(\\lambda\\)) at community levels for INLA models — likelihood.lambda.INLA","text":"initial value randomized 0.2 0.8, results capped 0 1. function start extremes avoid L-BFGS-B terminating prematurely.","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://tpaknok.github.io/CPR/reference/likelihood.lambda.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimizing phylogenetic signals (\\(\\lambda\\)) at community levels for GLS — likelihood.lambda","title":"Optimizing phylogenetic signals (\\(\\lambda\\)) at community levels for GLS — likelihood.lambda","text":"internal function called CPR_GLS. used optim, function compares AIC models different \\(\\lambda\\) identify best one using L-BFGS-B.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/likelihood.lambda.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimizing phylogenetic signals (\\(\\lambda\\)) at community levels for GLS — likelihood.lambda","text":"","code":"likelihood.lambda(lambda,   formula,   df,   VCV_sp,   comm,   ...)"},{"path":"https://tpaknok.github.io/CPR/reference/likelihood.lambda.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimizing phylogenetic signals (\\(\\lambda\\)) at community levels for GLS — likelihood.lambda","text":"lambda initial lambda. CPR_GLS default randomly select value 0.2-0.8 formula formula GLS df data frame VCV_sp phylogenetic covariance matrix species levels comm species-site matrix ... additional arguments passing optim.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/likelihood.lambda.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Optimizing phylogenetic signals (\\(\\lambda\\)) at community levels for GLS — likelihood.lambda","text":"initial value randomized 0.2 0.8, results capped 0 1. function start extremes avoid L-BFGS-B terminating prematurely.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/likelihood.lambda.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimizing phylogenetic signals (\\(\\lambda\\)) at community levels for GLS — likelihood.lambda","text":"returning (\\(\\lambda\\)) leading lowest AIC","code":""},{"path":[]},{"path":"https://tpaknok.github.io/CPR/reference/likelihood.lambda.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Optimizing phylogenetic signals (\\(\\lambda\\)) at community levels for GLS — likelihood.lambda","text":"Toby P. N. Tsang","code":""},{"path":[]},{"path":[]},{"path":[]}]
