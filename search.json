[{"path":"https://tpaknok.github.io/CPR/articles/Empirical.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Empirical Analyses with CPR","text":"R Markdown document describing empirical analyses conducted Tsang et al. (2024). , need install load multiple packages data. Let’s get variane covariance matrix species community level. KSR_EF data multiple ecosystem function.","code":"library(phytools) library(tidyverse) library(CPR) data(\"KSR\") data(\"KSR_MLtree\") data(\"KSR_EF\") VCV_sp <- vcv(KSR_MLtree) #species level phyologenetic covariance matrix using default (Brownian) model VCV_sp <- VCV_sp[order(rownames(VCV_sp)),order(colnames(VCV_sp))] VCV_comm <- get_comm_pair_r(KSR,VCV_sp) VCV_comm[1:5,1:5] #>           [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 1.0000000 0.7031681 0.5639611 0.5601336 0.7539047 #> [2,] 0.7031681 1.0000000 0.5458038 0.5420995 0.7048548 #> [3,] 0.5639611 0.5458038 1.0000000 0.9932127 0.5749535 #> [4,] 0.5601336 0.5420995 0.9932127 1.0000000 0.5710514 #> [5,] 0.7539047 0.7048548 0.5749535 0.5710514 1.0000000 head(KSR_EF) #>   Plot Real.rich litter2012 ave.biomass  LAI mean.N.change poll_total #> 1   X2         1      79.05    32.97333 1.67       -0.0015         20 #> 2   X3         4      74.23    82.41000 5.53       -0.0275         53 #> 3   X4         2      34.50    62.92667 3.04        0.0060        150 #> 4   X7         1      36.32    34.38333 3.42       -0.0575          0 #> 5   X8         3      21.46   147.05667 7.14       -0.0070          0 #> 6   X9         1      37.26    33.80333 1.01        0.0415          0 #>   flwr_total Mass.loss.2month Damage_effect bugs bug.rich #> 1 43113.5000            3.362     0.0000000    9        7 #> 2  2126.1429            3.718    -0.3001195    7        6 #> 3   324.4286            3.521    -0.4195279    4        2 #> 4     0.0000            3.328     0.0000000    5        3 #> 5     0.0000            3.608    -2.7460093    4        4 #> 6     0.0000            3.627     0.0000000   11        7"},{"path":[]},{"path":"https://tpaknok.github.io/CPR/articles/Empirical.html","id":"empirical-analyses","dir":"Articles","previous_headings":"","what":"Empirical analyses","title":"Empirical Analyses with CPR","text":"repeated analyses Cadotte et al. (2017), involving ten ecosystem functions. one ecosystem function interest (don’t mind code clunky), can just use INLA write similar functions ten times. example, let’s analyze flower abundance. INLA powerful package, can bit complicated use. Bayesian analysis, specify priors. INLA different default priors check website interested. , use penalizing complexity prior. specification identical phyr, R package Bayesian community PGLMM. case, used lapply analyze ecosystem function. codes complicated. Let’s define function analysis first Now let’s run . Now let’s visualize findings","code":"KSR_EF$log_flwr_total <- log10(KSR_EF$flwr_total+1) #log-transforming floral abundance to facilitate covnergence in INLA  KSR_EF$comm <- 1:nrow(KSR_EF) #need to create an unique identifier for each comm in INLA m <- lm(log_flwr_total~Real.rich,data=KSR_EF)  sdres <- sd(residuals(m)) param <- c(3*sdres,0.01) prior1 <- list(prec=list(prior=\"pc.prec\"),param=param) #You can specify your own prior too.   f <- log_flwr_total~Real.rich+f(comm,model=\"generic0\",Cmatrix=P.lambda,hyper=list(prec = prior1)) #start with the formula. Note that P.lambda is just a placeholder   ML.opt2<-optim(runif(1,0.2,0.8),                likelihood.lambda.INLA,                inla_formula= f,                family=\"gaussian\",                data=KSR_EF,                phyV=VCV_sp,                comm=KSR,                prior = list(prior1 = prior1),                control.compute = list(waic=T),                method=\"L-BFGS-B\",                lower=0.0,                upper=1.0,                control=list(factr=1e9)) #Slow  lambda_INLA<-ML.opt2$par wAIC <- ML.opt2$value VCV_sp_INLA <- VCV_sp*lambda_INLA diag(VCV_sp_INLA) <- diag(VCV_sp) C.lambda.INLA<- get_comm_pair_r(KSR,VCV_sp_INLA)   prec.mat.INLA <- solve(C.lambda.INLA) #note that INLA requires a precision matrix, not a VCV  optim_m <- inla(log_flwr_total~Real.rich+f(comm,                                            model=\"generic0\",                                            Cmatrix=prec.mat.INLA,                                            hyper=list(prec = prior1)),                 data=KSR_EF)  lm_m <- inla(log_flwr_total~Real.rich,                 data=KSR_EF)  summary(optim_m) summary(lm_m) ef_empiricial <- function(ef_data,x,VCV_sp,names,ef_properties,comm,family) {   print(ef_properties)   y <- ef_data   df <- data.frame(y=y,x=x)   df$comm <- 1:nrow(df)      m <- glm(y~x,            family = family,            data = df)      summary(m)   m_sig <- summary(m)$coefficients[2,4]    sdres <- sd(residuals(m))   param <- c(3*sdres,0.01)   prior1 <- list(prec=list(prior=\"pc.prec\"),param=param)      ML.opt2<-optim(runif(1,0.2,0.8),                  likelihood.lambda.INLA,                  inla_formula = f,                  family = family,                  data = df,                  phyV = VCV_sp,                  comm = KSR,                  prior = list(prior1 = prior1),                  control.compute = list(waic=T),                  method = \"L-BFGS-B\",                  lower = 0.0,                  upper = 1.0,                  control = list(factr=1e9))      lambda_INLA<-ML.opt2$par   wAIC <- ML.opt2$value   V_INLA <- VCV_sp*lambda_INLA   diag(V_INLA) <- diag(VCV_sp)   C.lambda.INLA<- get_comm_pair_r(comm,V_INLA)       newobs <- data.frame(y=NA,x=unique(x),comm=NA)   INLA_df <- rbind(df,newobs)      m2_INLA_LM <- inla(y~x,                      data=INLA_df,                      family=family,                      control.compute = list(dic=T,waic=T))   m2_INLA_LM <- inla.rerun(m2_INLA_LM)   wAIC_LM <- m2_INLA_LM$waic$waic   m2_INLA_LM_r2<- cor(m2_INLA_LM$summary.fitted.values[1:(nrow(df)),\"mean\"],df$y)^2      prec.mat.INLA <- solve(C.lambda.INLA)   m2_INLA_optim <- inla(y~x+f(comm,                               model=\"generic0\",                               Cmatrix=prec.mat.INLA,                               prior = \"pc.prec\",                               hyper= c(3*sd(residuals(m)),0.01)),                         family = family,                         data = INLA_df,control.predictor=list(compute=TRUE),                         control.compute = list(dic=T,waic=T),                         safe=T,                         control.inla = list(tolerance = 1e-10))   m2_INLA_optim <- inla.rerun(m2_INLA_optim) # https://groups.google.com/g/r-inla-discussion-group/c/qkoV9ZtA1Wo   m2_INLA_optim <- inla.rerun(m2_INLA_optim) # https://groups.google.com/g/r-inla-discussion-group/c/qkoV9ZtA1Wo      summary(m2_INLA_optim)   m2_INLA_optim_predict <- m2_INLA_optim$summary.fitted.values[-1:-(nrow(df)),]   m2_INLA_optim_predict <- data.frame(newobs$x,m2_INLA_optim_predict[,c(\"mean\",\"0.025quant\",\"0.975quant\")])   m2_INLA_optim_predict$sig <- ifelse(sign(m2_INLA_optim$summary.fixed)[2,3] ==     sign(m2_INLA_optim$summary.fixed)[2,5],-1,1)   m2_INLA_optim_r2 <- cor(m2_INLA_optim$summary.fitted.values[1:nrow(df),\"mean\"],df$y)^2      library(ggeffects)   m_predict <- data.frame(ggeffect(m,terms=\"x\"),sig=m_sig)   m_predict <- m_predict[,c(1,2,4,5,7)]   colnames(m2_INLA_optim_predict) <- colnames(m_predict)      ###summarize the data into a dataframe   predict_df <- rbind(cbind(m_predict,                             model=\"OLS\",                             ef=ef_properties,                             lambda=NA,                             hyper_Gaussian = NA,                              hyper_Comm = NA,                             wAIC = wAIC_LM,                             r2=m2_INLA_LM_r2,                             mean=m2_INLA_LM$summary.fixed[2,1],                             lower_quant=m2_INLA_LM$summary.fixed[2,3],                             upper_quant=m2_INLA_LM$summary.fixed[2,5]),                       cbind(m2_INLA_optim_predict,                             model=\"Optimized INLA\",                             ef=ef_properties,                             lambda=lambda_INLA,                             hyper_Gaussian=m2_INLA_optim$summary.hyperpar[1,1],                             hyper_Comm =m2_INLA_optim$summary.hyperpar[2,1],                             wAIC=wAIC,                             r2=m2_INLA_optim_r2,                             mean=m2_INLA_optim$summary.fixed[2,1],                             lower_quant=m2_INLA_optim$summary.fixed[2,3],                             upper_quant=m2_INLA_optim$summary.fixed[2,5]))      return(predict_df) } library(nlme) ef_name <- c(\"litter2012\",\"ave.biomass\",\"LAI\",\"bug.rich\",\"bugs\",\"poll_total\",\"log_flwr_total\",\"Mass.loss.2month\",\"Damage_effect\",\"mean.N.change\") #ecosystem functions analyzed ef <- KSR_EF[,ef_name] C <- get_comm_pair_r(KSR,VCV_sp)  f <- y~x+f(comm,model=\"generic0\",Cmatrix=P.lambda,hyper=list(prec = prior1)) family <- ifelse(ef_name == \"bug.rich\" | ef_name == \"bugs\" | ef_name == \"poll_total\",                  \"poisson\",                  \"gaussian\")  df <- data.frame(x=KSR_EF$Real.rich) #seems that ggeffect can only extract variables from global environments predict_df <- lapply(1:ncol(ef),function(x) ef_empiricial(ef_data=ef[,x],                                                           x=KSR_EF$Real.rich,                                                           VCV_sp=VCV_sp,                                                           ef_properties=ef_name[x],                                                           comm=KSR,                                                           family=family[x]))  predict_df <- do.call(rbind,predict_df) predict_df$x <- predict_df$x predict_df$sig_binary <- ifelse(predict_df$sig < 0.05,\"Significant\",\"Insignificant\") library(ggplot2) library(tidyverse) plot_data <- KSR_EF %>%    select(any_of(ef_name)|\"Real.rich\") %>%   pivot_longer(!Real.rich,names_to=\"ef\")  plot_data$ef <- fct_relevel(plot_data$ef,                             \"litter2012\",                             \"ave.biomass\",                             \"LAI\",                             \"poll_total\",                             \"log_flwr_total\",                             \"Mass.loss.2month\",                             \"Damage_effect\",                             \"mean.N.change\",                             \"bugs\",                             \"bug.rich\")  predict_df$ef <- fct_relevel(predict_df$ef,                              \"litter2012\",                              \"ave.biomass\",                              \"LAI\",                              \"poll_total\",                              \"log_flwr_total\",                              \"Mass.loss.2month\",                              \"Damage_effect\",                              \"mean.N.change\",                              \"bugs\",                              \"bug.rich\")  predict_df$ratio <- predict_df$hyper_Gaussian/predict_df$hyper_Comm predict_df$ratio <- (1/predict_df$hyper_Gaussian)/(1/predict_df$hyper_Comm)  p <- ggplot(data=predict_df)+   geom_jitter(data=plot_data,aes(y=value,x=Real.rich),width=0)+   geom_line(aes(y=predicted,x=x,colour=model,linetype=sig_binary))+   geom_ribbon(aes(y=predicted,x=x,fill=model,ymin=conf.low,ymax=conf.high),alpha=0.3,colour=\"transparent\")+   facet_wrap(~ef,scales=\"free\",nrow=5,ncol=2)+   theme_classic()+   labs(x=\"Species richness\",y=\"Ecosystem Function\",colour=\"Model\",fill=\"Model\",linetype=\"Significance\")+   scale_linetype_manual(values=c(2,1))+   scale_colour_manual(values=c(\"#000000\",\"#E69F00\"))+   scale_fill_manual(values=c(\"#000000\",\"#E69F00\"))+   theme(legend.position=\"bottom\")  plot(p)"},{"path":"https://tpaknok.github.io/CPR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Toby Pak Nok Tsang. Maintainer.","code":""},{"path":"https://tpaknok.github.io/CPR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Tsang TPN (2024). CPR: Community Phylogenetic Regression. R package version 0.1.0, https://tpaknok.github.io/CPR/, https://github.com/tpaknok/CPR.","code":"@Manual{,   title = {CPR: Community Phylogenetic Regression},   author = {Toby Pak Nok Tsang},   year = {2024},   note = {R package version 0.1.0, https://tpaknok.github.io/CPR/},   url = {https://github.com/tpaknok/CPR}, }"},{"path":"https://tpaknok.github.io/CPR/index.html","id":"cpr-under-development","dir":"","previous_headings":"","what":"Community Phylogenetic Regression","title":"Community Phylogenetic Regression","text":"package CPR address phylogenetic non-independence species community analyses.","code":""},{"path":"https://tpaknok.github.io/CPR/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Community Phylogenetic Regression","text":"can install development version CPR GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"tpaknok/CPR\",build_vignettes=TRUE,force=TRUE)"},{"path":"https://tpaknok.github.io/CPR/index.html","id":"background","dir":"","previous_headings":"","what":"Background","title":"Community Phylogenetic Regression","text":"species known non-independent due shared evolutionary history, rarely considered community-level analyses. Additionally, communities statistically indepedent species overlap (often case). analysis accounts non-independence species within communities using Bayesian GLMM. Composition matrices presence/absence, number individuals, percent cover, biomass etc can used. Matrices based scoring systems uneven intervals can also used (e.g., DAFOR), can lead interpretation issues. Users can calculate variance-covariance matrix based phylogeny model (e.g. Brownian motions). resulting variance-covariance matrix positive definite, nearPD Matrix package applied find nearest positive definite matrix. Without positive definite matrix PGLS fail run. Please make sure species compositional matrix phylogenetic matrix identical species name (e.g., space denoted ” “, ”_” “.”). “get_comm_pair_r” return variance-covariance matrix community level, can used gls (nlme). likelihood_lambda.R extracted Revell et al. (2010, Methods Ecology & Evolution). Similar PGLS, function optimizes phylogenetic covariance matrix minimizing log-likelihood. default lambda value restricted 0-1. functions used simulations / empirical analyses producing figures Note using Bayesian GLMM rather Frequentist GLMM improve speed.","code":""},{"path":"https://tpaknok.github.io/CPR/index.html","id":"known-problems","dir":"","previous_headings":"","what":"Known problems","title":"Community Phylogenetic Regression","text":"Might need use inla.rerun enhance model stability possible communities indeed independent sample even species overlap. cases optimization lambda produce unstable results. fix 1) re-run optimization several times see results largely stable 2) compare wAIC models optimized lambda independence assumption. model optimized lambda doesn’t perform better, users can use model assuming communities independent. Note even phylogenetic matrix, INLA give different results across runs. re-running model give different slightly different results (phylogeny important). phylogeny unimportant, INLA give unstable results, wAIC lambda values driven random fluctutation across runs.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"Getting pairwise phylogenetic correlation communities","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"","code":"get_comm_pair_r(comm,V,force.PD = TRUE)"},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"comm species-site matrix V phylogenetic covariance matrix species levels force.PD find closest positive definite matrix community levels.   Default TRUE. Note matrix positive definite subsequent analyses can fail.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"resulting phylogenetic correlation matrix based additive law covariance. Imagine two communities species (X,Y) species (X,Z). Covariance community levels   Cov(X+Y,X+Z) = Var(X)+Cov(X,Z)+Cov(X,Y)+Cov(Y,Z). components can obtained     species level phylogenetic matrix.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"phylogenetic correlation matrix community levels.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"https://github.com/tpaknok/CPR","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"Toby P.N. Tsang","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"","code":"library(phytools) #> Loading required package: ape #> Loading required package: maps library(tidyverse) #> ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── #> ✔ dplyr     1.1.4     ✔ readr     2.1.5 #> ✔ forcats   1.0.0     ✔ stringr   1.5.1 #> ✔ ggplot2   3.5.0     ✔ tibble    3.2.1 #> ✔ lubridate 1.9.3     ✔ tidyr     1.3.1 #> ✔ purrr     1.0.2      #> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── #> ✖ dplyr::filter() masks stats::filter() #> ✖ dplyr::lag()    masks stats::lag() #> ✖ purrr::map()    masks maps::map() #> ✖ dplyr::where()  masks ape::where() #> ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors library(CPR) data(KSR) data(KSR_MLtree) data(KSR_EF)  KSR_MLtree <- keep.tip(KSR_MLtree,colnames(KSR)) VCV_sp <- vcv(KSR_MLtree) #species level phyologenetic covariance matrix using default (Brownian) model VCV_comm <- get_comm_pair_r(KSR,VCV_sp) #> Loading required package: Matrix #>  #> Attaching package: ‘Matrix’ #> The following objects are masked from ‘package:tidyr’: #>  #>     expand, pack, unpack #> Loading required package: matrixcalc"}]
