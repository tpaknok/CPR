[{"path":"https://tpaknok.github.io/CPR/articles/Empirical_multiple.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Empirical Analyses with CPR - Multiple Functions","text":"Assuming multiple ecosystem functions analyse, can repeat code single ecosystem function analyses multiple times. bit annoying though, especially lot data! , provide example use loop . First, load data .","code":"library(phytools) library(tidyverse) library(CPR) library(INLA) data(\"KSR\") data(\"KSR_MLtree\") data(\"KSR_EF\") VCV_sp <- vcv(KSR_MLtree) #species level phyologenetic covariance matrix using default (Brownian) model VCV_sp <- VCV_sp[order(rownames(VCV_sp)),order(colnames(VCV_sp))] VCV_comm <- get_comm_pair_r(KSR,VCV_sp)"},{"path":"https://tpaknok.github.io/CPR/articles/Empirical_multiple.html","id":"data-explorations","dir":"Articles","previous_headings":"","what":"Data Explorations","title":"Empirical Analyses with CPR - Multiple Functions","text":"use lapply . ten ecosystem functions, different statistical properties. examples, arthropod abundance must integer, damage reduction effects continuous. visualize distributions different ecosystem functions, can see spike zero! Thus, use different distributions different ecosystem functions. example, use negative binomial integer data, zeroinflated negative binomial integer data many zeros. continuous data, can use normal distribution, tweedie distribution many zeroes. need create lists store different formulas, name distribution, priors different models. Let’s . inla.set.contro.family.default indicates use default priors hyperparameters. However, tweedie distribution, specified non-informative prior.","code":"plot(hist(KSR_EF$LAI)) plot(hist(KSR_EF$flwr_total))"},{"path":"https://tpaknok.github.io/CPR/articles/Empirical_multiple.html","id":"model-setups","dir":"Articles","previous_headings":"","what":"Model Setups","title":"Empirical Analyses with CPR - Multiple Functions","text":"can simply use lapply loop everything. take time run!!!","code":"y <- c(\"poll_total\",        \"bugs\",        \"bug.rich\",        \"litter2012\",        \"ave.biomass\",        \"flwr_total\",        \"Mass.loss.2month\",        \"LAI\",        \"mean.N.change\",        \"Damage_effect\") #response  x <- \"Real.rich\" # predictors re <- 'f(comm,model=\"generic0\",Cmatrix=Phylo)' #random effect  family <- list(\"zeroinflatednbinomial1\",             \"nbinomial\",             \"nbinomial\",             \"gaussian\",             \"gaussian\",             \"tweedie\",             \"gaussian\",             \"gaussian\",             \"gaussian\",             \"gaussian\") #family for each response  formulas <- lapply(paste0(y,\"~\",x,\"+\",re),function(x) as.formula(x))  control.family<- list(inla.set.control.family.default(\"zeroinflatednbinomial1\"),                       inla.set.control.family.default(\"nbinomial\"),                       inla.set.control.family.default(\"nbinomial\"),                       inla.set.control.family.default(\"gaussian\"),                       inla.set.control.family.default(\"gaussian\"),                        list(hyper = list(                          theta1 = list(initial = 0),                          theta2 = list(initial = 0,                                        prior = \"normal\",                                        param = c(0,2)))),                       inla.set.control.family.default(\"gaussian\"),                       inla.set.control.family.default(\"gaussian\"),                       inla.set.control.family.default(\"gaussian\"),                       inla.set.control.family.default(\"gaussian\")) #hyperparameter priors  KSR_EF_list <- lapply(1:10,function(x) KSR_EF) #create ten sets of KSR_EF data comm_list <- lapply(1:10, function(x) KSR) #ten sets of comm data  KSR_EF_list[[10]] <- subset(KSR_EF_list[[10]], Real.rich > 1) #for damage effect, we exclude monoculture communities comm_list[[10]] <- KSR[rowSums(KSR) >1,] #for damage effect, we exclude monoculture communities"},{"path":"https://tpaknok.github.io/CPR/articles/Empirical_multiple.html","id":"empirical-analyses---multiple-functions","dir":"Articles","previous_headings":"","what":"Empirical Analyses - Multiple Functions","title":"Empirical Analyses with CPR - Multiple Functions","text":"","code":"BEF_KSR <- lapply(1:length(family), function(x) CPR(formulas[[x]],                                                     priors=NULL,                                                     df = KSR_EF_list[[x]],                                                     VCV_sp = VCV_sp,                                                     comm=comm_list[[x]],                                                     family=family[[x]],                                                     control.family=control.family[[x]],                                                     inla.rerun=3,                                                     optim.lambda = T)) #> [1] \"poll_total\" #> [1] \"bugs\" #> [1] \"bug.rich\" #> [1] \"litter2012\" #> [1] \"ave.biomass\" #> [1] \"flwr_total\" #>  #>  *** inla.core.safe:  The inla program failed, but will rerun in case better initial values may help. try=1/1  #>  #>  *** inla.core.safe:  rerun with improved initial values  #> [1] \"Mass.loss.2month\" #> [1] \"LAI\" #> [1] \"mean.N.change\" #> [1] \"Damage_effect\""},{"path":"https://tpaknok.github.io/CPR/articles/Empirical_multiple.html","id":"visualizations","dir":"Articles","previous_headings":"","what":"Visualizations","title":"Empirical Analyses with CPR - Multiple Functions","text":"visualize expected effect species richness different ecosystem functions, need extract predictions model. make figure, also need restructure KSR_EF wide format long format. Also, flower abundance ranged 0-60000, presented findings log-scale (although analyses log transform , tweedie use log link). Now just ggplot2 code, figure Tsang et al. (2024) produced.","code":"all_predictions <- do.call(rbind,sapply(1:10, function(x) BEF_KSR[[x]]$prediction)) plot_data <- KSR_EF %>%   select(any_of(y)|\"Real.rich\") %>%   pivot_longer(!Real.rich,names_to=\"response\")  plot_data$value[plot_data$response == \"flwr_total\"] <- log(plot_data$value[plot_data$response == \"flwr_total\"]+1) all_predictions[all_predictions$response == \"flwr_total\",c(\"0.5quant\",\"0.025quant\",\"0.975quant\")] <- log(all_predictions[all_predictions$response == \"flwr_total\",c(\"0.5quant\",\"0.025quant\",\"0.975quant\")]+1) library(ggplot2) p <- ggplot(data=all_predictions)+   geom_jitter(data=plot_data,aes(y=value,x=Real.rich),width=0)+   geom_line(aes(y=`0.5quant`,x=Real.rich,colour=model,linetype=Sig))+   geom_ribbon(aes(y=`0.5quant`,x=Real.rich,fill=model,ymin=`0.025quant`,ymax=`0.975quant`),alpha=0.3,colour=\"transparent\")+   facet_wrap(~response,scales=\"free\",nrow=5,ncol=2)+   theme_classic()+   labs(x=\"Species richness\",y=\"Ecosystem function\",colour=\"Model\",fill=\"Model\",linetype=\"Significance\")+   scale_linetype_manual(values=c(2,1))+   scale_colour_manual(values=c(\"#000000\",\"#E69F00\"))+   scale_fill_manual(values=c(\"#000000\",\"#E69F00\"))+   theme(legend.position=\"bottom\")  plot(p)"},{"path":"https://tpaknok.github.io/CPR/articles/Empirical_single.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Empirical Analyses with CPR - Single Function","text":"R Markdown document describing use CPR conduct BEF regression, community-level analyses. need install load multiple packages data. Let’s get variane covariance matrix species community level. KSR_EF data multiple ecosystem function.","code":"library(phytools) library(tidyverse) library(CPR) data(\"KSR\") data(\"KSR_MLtree\") data(\"KSR_EF\") VCV_sp <- vcv(KSR_MLtree) #species level phyologenetic covariance matrix using default (Brownian) model VCV_sp <- VCV_sp[order(rownames(VCV_sp)),order(colnames(VCV_sp))] VCV_comm <- get_comm_pair_r(KSR,VCV_sp) VCV_comm[1:5,1:5] #>           [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 1.0000000 0.7031681 0.5639611 0.5601336 0.7539047 #> [2,] 0.7031681 1.0000000 0.5458038 0.5420995 0.7048548 #> [3,] 0.5639611 0.5458038 1.0000000 0.9932127 0.5749535 #> [4,] 0.5601336 0.5420995 0.9932127 1.0000000 0.5710514 #> [5,] 0.7539047 0.7048548 0.5749535 0.5710514 1.0000000 head(KSR_EF) #>   Plot Real.rich litter2012 ave.biomass  LAI mean.N.change poll_total flwr_total Mass.loss.2month Damage_effect bugs bug.rich #> 1   X2         1      79.05    32.97333 1.67       -0.0015         20 43113.5000            3.362     0.0000000    9        7 #> 2   X3         4      74.23    82.41000 5.53       -0.0275         53  2126.1429            3.718     0.3001195    7        6 #> 3   X4         2      34.50    62.92667 3.04        0.0060        150   324.4286            3.521     0.4195279    4        2 #> 4   X7         1      36.32    34.38333 3.42       -0.0575          0     0.0000            3.328     0.0000000    5        3 #> 5   X8         3      21.46   147.05667 7.14       -0.0070          0     0.0000            3.608     2.7460093    4        4 #> 6   X9         1      37.26    33.80333 1.01        0.0415          0     0.0000            3.627     0.0000000   11        7"},{"path":[]},{"path":"https://tpaknok.github.io/CPR/articles/Empirical_single.html","id":"empirical-analyses---single-function","dir":"Articles","previous_headings":"","what":"Empirical Analyses - Single Function","title":"Empirical Analyses with CPR - Single Function","text":"repeated analyses Cadotte et al. (2017), involving ten ecosystem functions. one ecosystem function interest (don’t mind code clunky), can just use INLA write similar functions ten times. example, let’s analyze flower abundance. INLA powerful package, can bit complicated use. Bayesian analysis, specify priors. INLA different default priors check website interested. simplicty’s sake, use default prior random fixed effects, uninformative case. However, dispersion parameter tweedie, actually used gaussian distribution N~(0,2). Note prior log-scale internal calculation INLA. ’s default setting loggamma (100,100) seems narrow range, thus becoming informative, least dataset. Generally, think carefully prior constructions. Default priors always uninformative, can huge influence data! syntax INLA different packages like lme4 glmmTMB. random effect, need use f() provide necessary argument. manually computed covariance matrix, need first convert precision matrix, throw Cmatrix argument. Also, need set model “generic0”. use CPR, need supply species-level covariance matrix VCV_sp, add “Phylo” Cmatrix argument. Phylo just placeholder internal calculation CPR automatically convert covariance matrix precision matrix (even optimize covariance matrix wish ). also need add ID plot, CPR function internally create column named “comm” automatically. INLA sometimes might fail run, rerun automatically. don’t need worry . choose optimize phylogenetic signal, might take run! patient!","code":"inla_m <- CPR(formula = bugs~Real.rich+f(comm,model=\"generic0\",Cmatrix=Phylo),               priors=NULL,               df = KSR_EF,               VCV_sp = VCV_sp,               comm=KSR,               family=\"nbinomial\",               optim.lambda = T) #> [1] \"bugs\"  summary(inla_m$best_model) #>  #> Call: #>    c(\"inla.core(formula = formula, family = family, contrasts = contrasts, \", \" data = data, quantiles = quantiles,  #>    E = E, offset = offset, \", \" scale = scale, weights = weights, Ntrials = Ntrials, strata = strata, \", \" lp.scale  #>    = lp.scale, link.covariates = link.covariates, verbose = verbose, \", \" lincomb = lincomb, selection = selection,  #>    control.compute = control.compute, \", \" control.predictor = control.predictor, control.family = control.family,  #>    \", \" control.inla = control.inla, control.fixed = control.fixed, \", \" control.mode = control.mode,  #>    control.expert = control.expert, \", \" control.hazard = control.hazard, control.lincomb = control.lincomb, \", \"  #>    control.update = control.update, control.lp.scale = control.lp.scale, \", \" control.pardiso = control.pardiso,  #>    only.hyperparam = only.hyperparam, \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads = num.threads,  #>    \", \" keep = keep, working.directory = working.directory, silent = silent, \", \" inla.mode = inla.mode, safe =  #>    FALSE, debug = debug, .parent.frame = .parent.frame)\" )  #> Time used: #>     Pre = 0.201, Running = 0.253, Post = 0.182, Total = 0.636  #> Fixed effects: #>              mean    sd 0.025quant 0.5quant 0.975quant  mode kld #> (Intercept) 2.117 0.355      1.382    2.129      2.784 2.129   0 #> Real.rich   0.073 0.098     -0.119    0.074      0.266 0.073   0 #>  #> Random effects: #>   Name     Model #>     comm Generic0 model #>  #> Model hyperparameters: #>                                                        mean    sd 0.025quant 0.5quant 0.975quant mode #> size for the nbinomial observations (1/overdispersion) 2.53 0.514      1.672     2.48       3.68 2.38 #> Precision for comm                                     2.37 1.318      0.758     2.07       5.76 1.58 #>  #> Watanabe-Akaike information criterion (WAIC) ...: 617.33 #> Effective number of parameters .................: 11.73 #>  #> Marginal log-Likelihood:  -865.84  #>  is computed  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')"},{"path":"https://tpaknok.github.io/CPR/articles/Empirical_single.html","id":"residual-checking","dir":"Articles","previous_headings":"","what":"Residual Checking","title":"Empirical Analyses with CPR - Single Function","text":"Let’s model diagnostics make sure model makes sense. First, use function INLA_simulate obtain simulated response model. put DHARMa conduct different diagnostics. can see data don’t deviate lot expected line QQ plot, good thing. Also, obvious pattern residual graph….model ok. Now let’s try run analyses poisson distribution see happens. hyperparameter gaussian distribution use default settings INLA.","code":"library(DHARMa) sres <- INLA_simulate(inla_m$best_model) DHARMa_res <- createDHARMa(sres,                            KSR_EF$bugs,                            fittedPredictedResponse=inla_m$predictedfittedresponse,                            integerResponse = T) plot(DHARMa_res,quantreg=F)"},{"path":"https://tpaknok.github.io/CPR/articles/Empirical_single.html","id":"a-bad-example","dir":"Articles","previous_headings":"","what":"A bad example","title":"Empirical Analyses with CPR - Single Function","text":"Clearly worse fit negative binomial! knew poisson distributions often fail describe ecological data properly. functions DHARMa, check package build robust models!","code":"inla_m2 <- CPR(formula = bugs~Real.rich+f(comm,model=\"generic0\",Cmatrix=Phylo),               priors=NULL,               df = KSR_EF,               VCV_sp = VCV_sp,               comm=KSR,               family=\"poisson\") #> [1] \"bugs\"  summary(inla_m2$best_m) #> Length  Class   Mode  #>      0   NULL   NULL  sres2 <- INLA_simulate(inla_m2$best_model) DHARMa_res2 <- createDHARMa(sres2,                            KSR_EF$bugs,                            inla_m2$best_model$predictedfittedresponse,                            integerResponse=T) plot(DHARMa_res2,quantreg=F)"},{"path":"https://tpaknok.github.io/CPR/articles/Empirical_single.html","id":"making-figures","dir":"Articles","previous_headings":"","what":"Making figures","title":"Empirical Analyses with CPR - Single Function","text":"Let’s say want visualize predicted relationships arthropod abundance species richness. Note predict functions doesn’t work INLA, many packages don’t support INLA . use CPR, result automatically provide predicted relationships can pass ggplot make pretty figures. variable, CPR create list. Thus example can extract predicted relationship inla_m$prediction$Real.rich want visualize expected effect species richness. course can just visualize effect /without phylogeny, depending one fits better. Anyway, based models, can conclude","code":"library(ggplot2)  p <- ggplot()+   geom_point(data=KSR_EF,aes(x=Real.rich,y=bugs))+   geom_line(data=inla_m$prediction$Real.rich,aes(x=Real.rich,                                                  y=`0.5quant`,                                                  colour=model))+   geom_ribbon(data=inla_m$prediction$Real.rich,aes(x=Real.rich,                                                    y=`0.5quant`,                                                    ymin=`0.025quant`,                                                    ymax=`0.975quant`,                                                    fill=model,                                                    ),alpha=0.3)+   scale_colour_manual(values=c(\"#000000\",\"#E69F00\"))+   scale_fill_manual(values=c(\"#000000\",\"#E69F00\"))+   labs(x=\"Species Richness\",y = \"Arthropod Abundance\")+   theme_classic()  plot(p)"},{"path":"https://tpaknok.github.io/CPR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Toby Pak Nok Tsang. Maintainer.","code":""},{"path":"https://tpaknok.github.io/CPR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Tsang TPN (2024). CPR: Community Phylogenetic Regression. R package version 0.1.0, https://tpaknok.github.io/CPR/, https://github.com/tpaknok/CPR.","code":"@Manual{,   title = {CPR: Community Phylogenetic Regression},   author = {Toby Pak Nok Tsang},   year = {2024},   note = {R package version 0.1.0, https://tpaknok.github.io/CPR/},   url = {https://github.com/tpaknok/CPR}, }"},{"path":"https://tpaknok.github.io/CPR/index.html","id":"cpr-under-development","dir":"","previous_headings":"","what":"Community Phylogenetic Regression","title":"Community Phylogenetic Regression","text":"package CPR address phylogenetic non-independence species community analyses.","code":""},{"path":"https://tpaknok.github.io/CPR/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Community Phylogenetic Regression","text":"can install development version CPR GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"tpaknok/CPR\")"},{"path":"https://tpaknok.github.io/CPR/index.html","id":"background","dir":"","previous_headings":"","what":"Background","title":"Community Phylogenetic Regression","text":"species known non-independent due shared evolutionary history, rarely considered community-level analyses. Additionally, communities statistically indepedent species overlap (often case). analysis accounts non-independence species within communities using Bayesian GLMM. Composition matrices presence/absence, number individuals, percent cover, biomass etc can used. Matrices based scoring systems uneven intervals can also used (e.g., DAFOR), can lead interpretation issues. Users can calculate variance-covariance matrix based phylogeny model (e.g. Brownian motions). resulting variance-covariance matrix positive definite, nearPD Matrix package applied find nearest positive definite matrix. Without positive definite matrix PGLS fail run. Please make sure species compositional matrix phylogenetic matrix identical species name (e.g., space denoted ” “, ”_” “.”). “get_comm_pair_r” return variance-covariance matrix community level, can used gls (nlme). likelihood_lambda.R extracted Revell et al. (2010, Methods Ecology & Evolution). Similar PGLS, function optimizes phylogenetic covariance matrix minimizing log-likelihood. default lambda value restricted 0-1. functions used simulations / empirical analyses producing figures Note using Bayesian GLMM rather Frequentist GLMM improve speed.","code":""},{"path":"https://tpaknok.github.io/CPR/index.html","id":"known-problems","dir":"","previous_headings":"","what":"Known problems","title":"Community Phylogenetic Regression","text":"Might need use inla.rerun enhance model stability possible communities indeed independent sample even species overlap. cases optimization lambda produce unstable results. fix 1) re-run optimization several times see results largely stable 2) compare wAIC models optimized lambda independence assumption. model optimized lambda doesn’t perform better, users can use model assuming communities independent. Note even phylogenetic matrix, INLA give different results across runs. re-running model give different slightly different results (phylogeny important). phylogeny unimportant, INLA give unstable results, wAIC lambda values driven random fluctutation across runs.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"Getting pairwise phylogenetic correlation communities","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"","code":"get_comm_pair_r(comm,V,force.PD = TRUE)"},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"comm species-site matrix V phylogenetic covariance matrix species levels force.PD find closest positive definite matrix community levels.   Default TRUE. Note matrix positive definite subsequent analyses can fail.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"resulting phylogenetic correlation matrix based additive law covariance. Imagine two communities species (X,Y) species (X,Z). Covariance community levels   Cov(X+Y,X+Z) = Var(X)+Cov(X,Z)+Cov(X,Y)+Cov(Y,Z). components can obtained     species level phylogenetic matrix.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"phylogenetic correlation matrix community levels.","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"https://github.com/tpaknok/CPR","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"Toby P.N. Tsang","code":""},{"path":"https://tpaknok.github.io/CPR/reference/get_comm_pair.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting pairwise phylogenetic correlation between communities — get_comm_pair_r","text":"","code":"library(phytools) library(tidyverse) library(CPR) data(KSR) data(KSR_MLtree) data(KSR_EF)  KSR_MLtree <- keep.tip(KSR_MLtree,colnames(KSR)) VCV_sp <- vcv(KSR_MLtree) #species level phyologenetic covariance matrix using default (Brownian) model VCV_comm <- get_comm_pair_r(KSR,VCV_sp)"}]
